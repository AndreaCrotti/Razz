RAZZ SIMULATION
#+OPTIONS: toc:nil num:t

* Problem
  Given an initial configuration (3 initial cards for player 1 and 1 for each other player) simulate a very large number of games.
  For every game get the rank obtained by player 1, where poker and flushes are discarded and the rank is computed with the [[http://en.wikipedia.org/wiki/Razz_%2528poker%2529][rules of razz poker]].

  For example running
#+begin_src sh
  ./razz 3 A 2 3
#+end_src
  Will run 10^3 simulations with only one player which has as initial cards Ace, 2 and 3.
  The simulator must extract a total of 7 cards and take the 5 that give the best hand for razz.
  
#+begin_src sh
  ./razz.py 3 A 2 3
  -1        0.031     
  5         0.076     
  6         0.105     
  7         0.144     
  8         0.166     
  9         0.138     
  10        0.118     
  11        0.109     
  12        0.077     
  13        0.036  
#+end_src

  And it's interpreted as
  - there is 3% of probability to get a /null/ hand
  - there is 7% of getting a 5, which represents the best hand possible in Razz.
  And so on.
  
* A probabilistic solver
  Given the assumption that cards dealt to the other players don't interfere we can easily generate *all* the possible games and get the real probabilities.
  This could be useful to check whether the randomized algorithm also works correctly.
  
  It's enough to follow those steps:
  - take in input the cards
  - remove them from the deck
  - for every possible combination of 4 out of the remaining cards
    + generate a razzHand
    + rank it

  For this we use *itertools* in python which is very fast.
  All the possible combinations that we need to rank are
  $Binomial(TOT\_CARDS - INITIAL\_CARDS, 4)$

* Randomized solver
  Instead of computing the probabilities it's faster to extract cards randomly for a big number of times and compute the result /a posteriori/.

** General considerations
   The most important thing to get a fast and well written program is to select the right data structure.
   We can consider those entities:
   - Card
     simply an integer, we don't need to keep track of the suit also.
   - Deck
     On a deck we must be able to
     + remove given cards (from 3 up to 10 in initialization phase only)
     + select and remove random cards (4 in simplified case up to 46 in the completely fair version)
     
     For this structure I chose a list/array, 52 Integers is really small and the access is always linear.
     Different considerations on sorting are done later

   - Hand
     A hand is simply a set of card that each player has in every stage of the game, we must be able to:
     + add cards
     + compute the rank
     
     Here I chose a dictionary, which maps every card to the number of occurrences in the hand.
     Adding a card is just a *dict[x]++* and ranking is also very fast.

** Python
   In python I didn't try to optimize as much as in C, because the code would be much less clean and I wouldn't still get comparable performances.

*** Deck
    The deck is a list of integers, we need to remove a list of cards from it and to extract random cards.
    Extraction is done picking one card with choice and removing it.
    It's still much faster than shuffling the deck every time.

#+begin_src python
  c = choice(self.cards)
  self.cards.remove(c)
#+end_src

*** Hand
    A hand is a dictionary \\
    [card : occurrences]
    Adding cards is straightforward and computing the rank is also very easy, we can simply
    - sort the keys (which represent the different cards present)
    - if they're less than necessary it's at least a couple and we discard it, otherwise we take the k_{th} card

** C
   C code is written in c99 standard (not ansi).
   To make C code run as fast as possible we should avoid every expansive operation, like allocation of data structures at every cycle.
*** Deck
    The deck is a structure containing:
    - array of cards
    - original length
    - current length

    To get a real simulation we should shuffle the whole deck at every game, but that's too expansive.
    Another way is picking random cards with a random index in the range of the length. \\
    Even if the card to pick randomly are just a few we could still pick the same card, and randomly choose until one free card is found is in general not a good idea.

    So I just shrink the array at every step swapping the chosen element with the last one.

    For example: \\
    [1, 2, 4, 3] \\

    We pick index 1, so 2 must be extracted \\
    [1, 3, 4 | 2] \\
    
    We swapped 2 with 3 and decremented the actual length.

    Keeping the original deck as it is and just moving one index is very useful because to reset the deck we just need to put it back \\
    *deck->len = deck->orig\_len;*
    
*** Hand
    A hand is implemented like in python, with a dictionary [Card : #], with the difference that here when we need to always keep all indices.
    So we also keep a variable *diffs* which keeps track of how many different cards have been found.
    The rank then will be:
    - *-1* if we don't have enough different cards
    - the *diffs - eval + 1* card found scanning backwards the array otherwise
    
    A possible improvement would be to rank direcly in *give_cards*, whenever we know we'll certainly have a couple we could return *-1* (or call rank_hand when not possible).
    In avarage is a bit faster but introduces a coupling between two functions which breaks the [[http://en.wikipedia.org/wiki/Single_responsibility_principle][SRP]].

*** Random generator
    Using random and lrand48 gives exactly the same result (while rand differs).    And lrand48 is the slowest, also avoid using the modulo, is slower and it only uses least significant bits.
    The random() function uses a non-linear, additive feedback, random number generator, employing a
    default table of size 31 long integers.  It returns successive pseudo-random numbers in the range from
    0 to (2**31)-1.  The period of this random number generator is very large, approximately
    16*((2**31)-1).

    The rand48() family of functions generates pseudo-random numbers, using a linear congruential algorithm
    working on integers 48 bits in size.  The particular formula employed is r(n+1) = (a * r(n) + c) mod m.
    The default value for the multiplicand `a' is 0xfdeece66d (25214903917).  The default value for the the
    addend `c' is 0xb (11).  The modulo is always fixed at m = 2 ** 48.  r(n) is called the seed of the
    random number generator.
    
* Testing
  I used nose for testing python code, it looks in the current directory and try to run all the tests that it finds.

* Objectives
  - Design a nice structure
  - See how to run test units in many languages
  - Compare the performances and the possibilities given
  - Make it fast!

* Speed comparison                                                 :noexport:

** Pure python
   Python can't be 

** Pure C
   C program for simulations runs very fast, in fact as you can see the bottleneck became the ramdom number generator.
   [[file:profiled.pdf]]

* Random generators
  - [[http://en.wikipedia.org/wiki/Pseudorandom_number_generator][Pseudorandom number generator]]
  - [[http://www.ams.org/featurecolumn/archive/random.html][nothing left to chance]]
  - [[http://www.random.org/randomness/][random.org]]
  - [[http://faculty.rhodes.edu/wetzel/random/intro.html][can you behave randomly?]]

  This little simulation is based on the fact that randomness works.
  Pseudo random generators don't create real random numbers, but use a procedure that hides the footprints so that the numbers create the *illusion* of randomness.
  
  This generators normally need a *seed*, which is the starting point of the sequence which will be created.
  /random numbers should not be generated with a method chosen at random/ (Knuth)

  A good way to generate pseudo random numbers comes from the *linear congruential generators*.

** Linear congruential generators
   $X_{n+1} = f (X_n) = (aX_n + c) % m$
   The trick is to find the right values of /a/, /c/ and /m/.
   The maximal length of the sequence that we can get is /m/, and using the correct values we can maximize it.

** Other possible generators
   - [[http://en.wikipedia.org/wiki/Multiply-with-carry][multiple with carry]]
     very fast and using only arithmetic given a large amount of random seeds
     It uses a similar formula to linear congruential generators but here the /c/ changes at every execution.
   - [[http://en.literateprograms.org/Mersenne_twister_(C)][mersenne twister]]

** Testing random generators
   There are a few tests that can be done to test if a random generator is working correctly
   - Frequency test
   - Permutation test
   - Run test
   - Gap test
   - Poker test
   - Birthday test
