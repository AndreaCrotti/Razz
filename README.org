RAZZ SIMULATION
#+OPTIONS: toc:nil num:nil
# Look in the bayesian formula to see how to get the probabilities correctly

* Problem
  Given an initial configuration (3 initial cards for player 1 and 1 for each other player) simulate a very large number of games. \\
  For every game get the rank obtained by player 1, where poker and flushes are discarded and the rank is computed with the rules of razz.

  For example running
#+begin_src sh
  ./razz 3 1 A 2 3
#+end_src
  Will run 10^3 simulations with only one player which has as initial cards Ace, 2 and 3.
  
This would be the output
#+begin_src sh
-1:	35
5:	77
6:	112
7:	138
8:	132
9:	159
10:	124
11:	103
12:	76
13:	44
#+end_src
  
* Implentation

** General considerations
   The most important thing to get a fast and well written program is to select the right data structure.
   We can consider those entities:
   - Card
     simply an integer, we don't need to keep track of the suit also.
   - Deck
     On a deck we must be able to
     + remove given cards (from 3 up to 10 in initialization phase only)
     + select and remove random cards (4 in simplified case up to 46 in the completely fair version)
     
     For this structure I chose a list/array, 52 Integers is really small and the access is always linear.
     Different considerations on sorting are done later

   - Hand
     A hand is simply a set of card that each player has in every stage of the game, we must be able to:
     + add cards
     + compute the rank
     
     Here I chose a dictionary, which maps every card to the number of occurrences in the hand.
     Adding a card is just a *dict[x]++* and ranking is also very fast.

** Python
   In python I didn't try to optimize as much as in C, because the code would be much less clean and I wouldn't still get comparable performances.

*** Deck
    The deck is a list of integers, we need to remove a list of cards from it and to extract random cards.
    Extraction is done picking one card with choice and removing it.
    It's still much faster than shuffling the deck every time.

#+begin_src python
c = choice(self.cards)
# check that I'm actually removing the first one
self.cards.remove(c)
#+end_src

*** Hand
    A hand is a dictionary \\
    [card : occurrences]
    Adding cards is straightforward and computing the rank is also very easy, we can simply
    - sort the keys (which represent the different cards present)
    - if they're less than necessary it's at least a couple and we discard it, otherwise we take the k_{th} card


** C
   C code is written in c99 standard (not ansi).
   To make C code run as fast as possible we should avoid every expansive operation, like allocation of data structures at every cycle.
*** Deck
    The deck is a structure containing:
    - array of cards
    - original length
    - current length

    To get a real simulation we should shuffle the whole deck at every game, but that's too expansive.
    Another way is picking random cards with a random index in the range of the length. \\
    To avoid picking the same card twice I shrink the array every time, swapping the selected card with the last one.

    For example: \\
    [1, 2, 4, 3] \\

    We pick index 1, so 2 must be extracted \\
    [1, 3, 4 | 2] \\
    
    We swapped 2 with 3 and decremented the actual length.

    Keeping the original deck as it is and just moving one index is very useful because to reset the deck we just need to put it back \\
    *deck->len = deck->orig\_len;*
    
*** Hand

*** Using random and lrand48 gives exactly the same result (while rand differs).    And lrand48 is the slowest, also avoid using the modulo, is slower and it only uses least significant bits.
     The random() function uses a non-linear, additive feedback, random number generator, employing a
     default table of size 31 long integers.  It returns successive pseudo-random numbers in the range from
     0 to (2**31)-1.  The period of this random number generator is very large, approximately
     16*((2**31)-1).

     The rand48() family of functions generates pseudo-random numbers, using a linear congruential algorithm
     working on integers 48 bits in size.  The particular formula employed is r(n+1) = (a * r(n) + c) mod m.
     The default value for the multiplicand `a' is 0xfdeece66d (25214903917).  The default value for the the
     addend `c' is 0xb (11).  The modulo is always fixed at m = 2 ** 48.  r(n) is called the seed of the
     random number generator.
    
* Testing
  I used [fn:1] for testing python code, it looks in the current directory and try to run all the tests that it finds.

* Timing/profiling

* Objectives
** Design a nice structure

** See how to run test units in many languages

** Compare the performances and the possibilities given

** Write a distributed version in erlang/python and see how they behaves

** Make it fast!
   A nice metric would be the
   #simulations / seconds
   The output could be equal for all the different languages and still parsable and analyzable automatically.

* Speed comparison

** Pure python

** Cython

** Pure C

* Random generators
  - [[http://en.wikipedia.org/wiki/Pseudorandom_number_generator][Pseudorandom number generator]]
  - [[http://www.ams.org/featurecolumn/archive/random.html][nothing left to chance]]
  - [[http://www.random.org/randomness/][random.org]]
  - [[http://faculty.rhodes.edu/wetzel/random/intro.html][can you behave randomly?]]

  This little simulation is based on the fact that randomness works.
  Pseudo random generators don't create real random numbers, but use a procedure that hides the footprints so that the numbers create the *illusion* of randomness.
  
  This generators normally need a *seed*, which is the starting point of the sequence which will be created.
  /random numbers should not be generated with a method chosen at random/ (Knuth)

  A good way to generate pseudo random numbers comes from the *linear congruential generators*.

** Linear congruential generators
   $X_{n+1} = f (X_n) = (aX_n + c) % m$
   The trick is to find the right values of /a/, /c/ and /m/.
   The maximal length of the sequence that we can get is /m/, and using the correct values we can maximize it.

** Other possible generators
   - [[http://en.wikipedia.org/wiki/Multiply-with-carry][multiple with carry]]
     very fast and using only arithmetic given a large amount of random seeds
     It uses a similar formula to linear congruential generators but here the /c/ changes at every execution.
   - [[http://en.literateprograms.org/Mersenne_twister_(C)][mersenne twister]]

** Testing random generators
   There are a few tests that can be done to test if a random generator is working correctly
   - Frequency test
   - Permutation test
   - Run test
   - Gap test
   - Poker test
   - Birthday test

* Footnotes

[fn:1] [[http://code.google.com/p/python-nose/][python nose]]
